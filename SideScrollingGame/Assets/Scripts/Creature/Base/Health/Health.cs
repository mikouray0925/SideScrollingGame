using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Health : MonoBehaviour
{
    [Header ("Health")]
    [SerializeField] float maxHealth;
    [SerializeField] float currentHealth;

    [Header ("Life")]
    [SerializeField] public int lifeRemain;
    [Range (0f, 1f)]
    [SerializeField] public float rebornPercentage;

    [Header ("other")]
    [SerializeField] public bool isInvincible;

    [Header ("protection")]
    [SerializeField] public CombinedAddend protection;

    protected SpriteRenderer rend;

    #region HealthPoint

    public float MaxHp {
        get {
            return maxHealth;
        }
        private set {
            maxHealth = value;
            currentHealth = Mathf.Clamp(currentHealth, 0f, maxHealth);
        }
    }

    //|=======================================================
    //| The "value" will be clamped between 0 and "maxHealth".
    //| Use "TakeDamage" function instead of "Hp -= x" 
    //| while being attacked.
    //| 
    //|=======================================================
    public float Hp {
        get {
            return currentHealth;
        }
        private set {
            if (lifeRemain <= 0) return;

            value = Mathf.Clamp(value, 0f, maxHealth);
            float deltaHealth = value - currentHealth;
            if (value > currentHealth) {
                SendMessage("OnHealthIncrease", deltaHealth, SendMessageOptions.DontRequireReceiver);
            }
            if (value < currentHealth) {
                SendMessage("OnHealthDecrease", deltaHealth, SendMessageOptions.DontRequireReceiver);
            }  
            currentHealth = value;

            if (currentHealth == 0) {
                lifeRemain--;
                if (lifeRemain > 0) {
                    currentHealth = maxHealth * rebornPercentage;
                    SendMessage("OnReborn", currentHealth, SendMessageOptions.DontRequireReceiver);
                } else {
                    SendMessage("OnLifeNumBecomeZero", null, SendMessageOptions.DontRequireReceiver);
                }
            }
        }
    }

    #endregion 

    public void Heal(float val) {
        Hp += val;
    }

    public void SetHealthPropotion(float propotion) {
        propotion = Mathf.Clamp(propotion, 0f, 1f);
        currentHealth = Mathf.Round(maxHealth * propotion * 10f) / 10f;
    }

    public void ScaleHealth(float scaler) {
        maxHealth = Mathf.Round(maxHealth * scaler * 10f) / 10f;
        currentHealth = Mathf.Round(currentHealth * scaler * 10f) / 10f;
    }

    #region Damage

    //|=======================================================
    //| Accept "damageInfo"<Damage> generated by <Attack>.
    //| If no life remains or "isInvincible" is true, 
    //| this function won't work.
    //| 
    //|=======================================================
    public void TakeDamage(Damage damageInfo) {
        if (lifeRemain <= 0 || isInvincible) return;  
        ProcessDamage(damageInfo, out float finalDamageVal);
        Hp -= finalDamageVal;
    }

    //|=======================================================
    //| When taking a <Damage>, we should process it, like 
    //| calculate the damage should take, apply the forces in 
    //| <Damage> to rb, play anim ...
    //| Write these in this func.
    //|=======================================================
    protected virtual void ProcessDamage(Damage damageInfo, out float finalDamageVal) {
        if (TryGetComponent<Rigidbody2D>(out Rigidbody2D _rb)) {
            foreach (Damage.Force forceInfo in damageInfo.forces) {
                _rb.AddForce(forceInfo.force, forceInfo.mode);
            }
        }
        if (protection) {
            finalDamageVal = damageInfo.damage - protection.Addend;
        } else {
            finalDamageVal = damageInfo.damage;
        }
    }

    #endregion

    #region Utility

    public void MakeSpriteFlash(Color color, float duraction, float delay = 0) {
        if (!rend) return;
        StartCoroutine(SpriteFlashCoroutine(color, duraction, delay));
    }

    public IEnumerator SpriteFlashCoroutine(Color color, float duraction, float delay) {
        yield return new WaitForSeconds(delay);
        // Color originalColor = rend.color;
        rend.color = color;
        yield return new WaitForSeconds(duraction);
        rend.color = Color.white;
    }

    #endregion
}
